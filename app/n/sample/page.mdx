import { AnimatedName } from '../animated-name.tsx';

export const metadata = {
  title: 'Product Engineers',
  description:
    'Product Engineers work backwards from the desired product experience to the set of technologies that enable it.',
  alternates: {
    canonical: '/n/product-engineers',
  },
};

# Product Engineers

<AnimatedName />



<details className="mb-1 -mt-2">
  <summary className="text-gray-600 text-[15px] mb-2">Majority: Server Components</summary>
  
    Most of the time, I fetch data in a Server Component (like a `page` or `layout`). Occasionally, I'll still use an external library for client-fetches (e.g. `swr`) when working with existing codebases.

</details>

<details className="mb-1 [&[open]]:mb-4 [&[open]]:border-b [&[open]]:border-gray-100">
  <summary className="text-gray-600 text-[15px] mb-2">Occasionally: React `use` + Context</summary>
  
    A newer pattern I've started using is forwarding Promises to a Context provider, and then "unwrapping" the Promise with React’s `use`.
    
    The data can then be used from a hook in any client component.
    
    This can work well if you have global data you need to use deep in the component tree (especially if there are lots of client components).
 
    <div className="h-4" />
</details>

<details className="space-y-6">
  <summary className="text-gray-600 text-[15px] mb-2">Why Tailwind?</summary>
  
  Tailwind uses a compiler to generate only the classes used. So while the utility CSS framework contains many possible class names, only the classes used will be included in the single, compiled CSS file.
  
  Assuming you only write Tailwind code, your bundle will never be larger than the total set of used Tailwind classes. It's extremely unlikely you would use them all. This means you have a fixed upper bound on the size of the generated CSS file, which is then minified, compressed, and cached for the best performance.
  
  You don't have to *only* write Tailwind styles. Tailwind classes are just utilities that adhere to a design system and work alongside normal CSS. You can mix and match Tailwind with CSS Modules, for example.

</details>


The divide between frontend and backend engineers is increasingly less useful:

- **Frontend developers** are no longer just writing HTML, CSS, and JavaScript. It's now common to see a frontend-focused developer build an entire web application from scratch. They integrate and connect to databases, handle authentication, and more.
- **Backend developers** are often forced to choose between two paths: writing more frontend code to support their backend, or moving closer towards managing, maintaining, and building software infrastructure used by the former developers.
- **AI-enhanced developers** have shifted the focus from simply writing code to creating great products. Startups are increasingly feeling this shift, running a more lean engineering team that uses LLMs and coding copilots to move faster.

## What are Product Engineers?

[Product Engineers](https://x.com/_swanson/status/1631691930345037824) work backwards from the desired product experience to the set of technologies that enable it. They consider the frontend, backend, design, and everything in between to create a great user experience.

They don't need to understand every part deeply, a common misconception of "fullstack". Instead, they have a [broad understanding](https://x.com/mipsytipsy/status/1659610352588562433) of the available tools and deep experience _applying_ those tools to build products.

Some qualities of a great Product Engineer:

- **Iterative:** They value [iteration velocity](https://twitter.com/rauchg/status/1681694545845833729) and incremental correctness. They'd rather ship, get feedback from customers, and adjust along the way—rather than building in a silo.
- **Customer focused:** They aren't afraid to engage with customers and learn how to improve the product. At a larger company, the Product Manager might specialize here, but should work closely with the engineer to _apply_ those learnings to the correct solutions.
- **Pragmatic:** They understand that technology choices are all means to an end. Choosing the latest JavaScript library doesn't matter if no one uses your product. They are willing to remove tools if they aren't helping fulfill their product goals.

Okay, so what does that leave the [other half](https://x.com/sophiebits/status/1404914237437190144) of the software engineers?

## Product vs. Platform Engineering

While Product Engineers focus on building and enhancing features that solve end user problems, [Platform Engineers](https://twitter.com/swyx/status/1097334440169107456) focus on the infrastructure that supports the product.

Platform Engineering teams are building or buying tools to support Product Engineers and make them more efficient, productive, and happier. They're typically making the infrastructure choices for the Product teams.

Typically, platforms teams were only something accessible for larger organizations. Increasingly, a small but effective group of Platform Engineers can make incredibly impactful decisions, even for smaller teams. They are thoughtful about evaluating and purchasing software to grow with the scale of their product team.

## Finding Talent

Most startups are looking for Fullstack Engineers but [actually need Product Engineers](https://x.com/parkerhendo/status/1686489366204645379). The best Product Engineers share two common qualities:

1. A passion for **building high-quality experiences**
2. A constant drive to **learn and explore new ideas**

They're not pixel-pushers; they're creators who take pride in their work and are not afraid to stand behind their products. They should have plenty of examples of their work, because so much of it is user facing.

They understand web fundamentals, such as browsers, accessibility, animations, CSS, HTML, and JavaScript. The tools they use—be it React, Svelte, or something else—are secondary. What truly matters is their ability to use these tools to build the best product possible.

Great Product Engineers don't stop at visually complete. They carefully consider the user journeys. What happens if there's slow (or no) internet connection? What if this API returns an error? How does this experience work on touch devices? What latency numbers should we strive for?

## Conclusion

Product Engineers represent a shift in web development. Especially with the [rise of AI](https://www.latent.space/p/ai-engineer), there's a growing need for developers who do more than "just write code" — developers who understand the bigger picture, who can work across various technologies, and who focus on delivering exceptional products to the end user.
